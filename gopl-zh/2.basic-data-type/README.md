Go语言将数据类型分为四类：**基础**类型、**复合**类型、**引用**类型和**接口**类型

Unicode字符rune类型是**和int32等价的类型**，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。

**无符号的整数类型**uintptr，没有指定具体的bit大小但是**足以容纳指针**

uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方

其中有符号整数采用**2的补码**形式表示，也就是**最高**bit位用来**表示符号**位，一个n-bit的有符号数的值域是从$`-2^{n-1}`$到$`2^{n-1}-1`$。无符号整数的所有bit位都用于表示非负数，值域是0到$`2^{n}-1`$。

**取模运算**符%仅用于**整数间的运算**: %取模运算符的符号**和被取模数的符号总是一致的**，因此-5%3和-5%-3结果都是-2

除法运算符/的行为则依赖于操作数**是否全为整数**，比如5.0/4.0的结果是1.25，但是5/4的结果是1，因为整数除法会**向着0方向截断余数**
(如果两个整数相除得到一个非整数结果，那么结果将会被截断为一个整数，并且截断规则是向着 0 的方向靠近)

**对于整数**，+x是0+x的简写，-x则是0-x的简写；**对于浮点数和复数**，+x就是x，-x则是x 的负数

对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型

```
f := 1e100  // a float64
o := 0666 // 8进制, strat with 0
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef) // (16进制, start with 0x or 0X)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x) // %之后的[1]副词告诉Printf函数再次使用第一个操作数。第二，%后的#副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀
```

字符面值通过**一对单引号**直接包含对应字符

**字符**使用%c参数打印，或者是用%q参数打印**带单引号的字符**：

```
ascii := 'a'
unicode := '国'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii)   // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
fmt.Printf("%d %[1]q\n", newline)       // "10 '\n'"
```

math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324

通常应该优先使用float64类型，因为float32类型的累计**计算误差**很容易**扩散**，并且float32能精确表示的正整数并不是很大
（译注：因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差）

```
const Avogadro = 6.02214129e23  // 阿伏伽德罗常数
const Planck   = 6.62606957e-34 // 普朗克常数 // 很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分
```

math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试：**正无穷大**和**负无穷大**，分别用于表示太大溢出的数字和除零的结果；
还有NaN**非数**，一般用于表示**无效的除法**操作结果0/0或Sqrt(-1).

```
var z float64
fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
```

函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值

虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为**NaN和任何数都是不相等**的
（译注：在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示）

布尔值可以和&&（AND）和||（OR）操作符结合，并且有**短路行为**：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，因此下面的表达式总是安全的：

```
s != "" && s[0] == 'x' // s[0]操作如果应用于空字符串将会导致panic异常
```

&&的优先级比||**高**（助记：&&对应**逻辑乘法**，||对应**逻辑加法**，乘法比加法优先级要高）

字符串可以包含任意的数据，包括byte值0

文本字符串通常**被解释为**采用UTF8编码的Unicode码点（**rune**）序列

内置的len函数可以返回一个字符串中的**字节数目**（**不是**rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束

第i个字节并不一定是字符串的第i个字符，因为**对于非ASCII字符的UTF8编码会要两个或多个字节**

一个**原生的字符串面值**形式是`...`，使用**反引号**代替**双引号**。在原生的字符串面值中，没有转义操作；全部的内容**都是字面的意思**，**包含退格和换行**，因此一个程序中的原生字符串面值可能跨越多行

Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。有两种形式：**\uhhhh**对应**16bit**的码点值，**\Uhhhhhhhh**对应**32bit**的码点值，其中**h**是一个**十六进制数字**

strings包提供了许多如字符串的**查询、替换、比较、截断、拆分和合并**等功能

bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，**使用bytes.Buffer类型将会更有效**

strconv包提供了布尔型、整型数、浮点数和对应字符串的**相互转换**，还提供了**双引号转义**相关的转换

unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类

常量表达式的值在编译期计算，而不是在运行期

常量间的所有**算术**运算、**逻辑**运算和**比较**运算的**结果也是常量**，对常量的类型转换操作或以下函数调用都是**返回常量结果**：len、cap、real、imag、complex和unsafe.Sizeof

如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略

```
const (
    a = 1
    b
    c = 2
    d
)

fmt.Println(a, b, c, d) // "1 1 2 2"
```
常量声明可以使用**iota常量生成器**初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。

在一个const声明语句中，在**第一个声明的常量所在的行**，iota将会**被置为0**，然后在每一个**有常量声明的行加一**

在其它编程语言中，这种类型一般被称为**枚举类型**

```
type Flags uint

const (
    FlagUp Flags = 1 << iota // is up
    FlagBroadcast            // supports broadcast access capability
    FlagLoopback             // is a loopback interface
    FlagPointToPoint         // belongs to a point-to-point link
    FlagMulticast            // supports multicast access capability
)

const (
    _ = 1 << (10 * iota)
    KiB // 1024
    MiB // 1048576
    GiB // 1073741824
    TiB // 1099511627776             (exceeds 1 << 32)
    PiB // 1125899906842624
    EiB // 1152921504606846976
    ZiB // 1180591620717411303424    (exceeds 1 << 64)
    YiB // 1208925819614629174706176
)
```

不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符

编译器为这些**没有明确基础类型**的**数字常量**提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。

这里有六种未明确类型的常量类型，分别是**无类型的布尔型**、**无类型的整数**、**无类型的字符**、**无类型的浮点数**、**无类型的复数**、**无类型的字符串**

**只有**常量可以是无类型的。
当一个无类型的常量被赋值给一个变量的时候，或者出现在有明确类型的变量声明的右边，**无类型的常量**将会被**隐式转换为对应的类型**，如果**转换合法**的话

无类型整数常量转换为int，它的内存大小是**不确定**的，但是**无类型浮点数和复数常量**则转换为**内存大小明确**的float64和complex128。 
如果**不知道浮点数类型的内存大小是很难写出正确的数值算法**的，因此Go语言**不存在**整型类似的**不确定内存大小的浮点数和复数类型**

当尝试将这些**无类型的常量转为**一个**接口值**时，这些默认类型将显得尤为重要，因为要靠它们**明确接口对应**的**动态类型**
