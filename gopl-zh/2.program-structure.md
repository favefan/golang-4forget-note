Go语言程序员推荐使用 **驼峰式** 命名

名字的**开头字母的大小**写决定了名字在**包外的可见性**。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问

Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明

```
var 变量名字 类型 = 表达式

var i, j, k int                 // int, int, int
var b, f, s = true, 2.3, "four" // bool, float64, string

i, j := 0, 1

i, j = j, i // 交换 i 和 j 的值

// 简短变量声明语句中必须至少要声明一个新的变量，下面的代码将不能编译通过：
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。
如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。
同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。

```
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```

任何类型的指针的零值都是nil。

**指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等**。

指针是实现flag包的关键技术之一，它可以方便地在函数间传递标志变量，并且可以避免在函数内部对标志变量进行拷贝。

表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T

**new函数类似是一种语法糖**

局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收

因为**一个变量的有效周期只取决于是否可达**，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。

**编译器会自动选择在栈上还是在堆上分配局部变量的存储空间**，但可能令人惊讶的是，这个选择并**不是由用var还是new声明变量的方式决定的**。

```
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

func g() {
    y := new(int)
    *y = 1
}

// f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的；
// 用Go语言的术语说，这个x局部变量从函数f中逃逸了。相反，当g函数返回时，变量*y将是不可达的，也就是说可以马上被回收的。
// 因此，*y并没有从函数g中逃逸，编译器可以选择在栈上分配*y的存储空间（译注：也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间），虽然这里用的是new方式。
// 其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响。
```

数值变量也可以支持++递增和--递减语句（译注：**自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的**）

需要注意的是，在Go中并没有元组类型，**元组赋值只是一种语法糖**，它是通过将多个值打包成一个结构体或数组来实现的。因此，在使用元组赋值时，需要注意元素的顺序和类型的匹配。

对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：**对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然**。

```
type 类型名字 底层类型
```

使用** type 关键字**定义的类型，本质上是一种**新的类型声明**，它们虽然底层类型相同，但是它们的**类型信息是不同的**。这是因为在 Go 中，类型不仅包括底层类型，还包括类型的名称、大小、方法集等元信息。

由于类型声明创建了一个新的类型，因此使用 type 定义的不同类型之间不能直接进行比较。但是能通过类型转换间接比较，或者和有着相同底层类型的未命名类型的值之间做比较:

```
var c Celsius
var f Fahrenheit
fmt.Println(c == 0)          // "true"
fmt.Println(f >= 0)          // "true"
fmt.Println(c == f)          // compile error: type mismatch
fmt.Println(c == Celsius(f)) // "true"!
```

在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。

比较运算符==和<也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较

**命名类型**还可以为该类型的值**定义新的行为（方法）**。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。我们将在第六章中讨论方法的细节，这里只说些简单用法。

下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串：

```
c := FToC(212.0)
fmt.Println(c.String()) // "100°C"
fmt.Printf("%v\n", c)   // "100°C"; no need to call String explicitly
fmt.Printf("%s\n", c)   // "100°C"
fmt.Println(c)          // "100°C"
fmt.Printf("%g\n", c)   // "100"; does not call String
fmt.Println(float64(c)) // "100"; does not call String
```

许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会**优先使用该类型对应的String方法返回**的结果打印

不要将作用域和生命周期混为一谈。**声明语句的作用域**对应的是一个源代码的文本区域；它是一个**编译时的属性**。一个**变量的生命周期**是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个**运行时的概念**。
